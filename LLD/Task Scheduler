Functional Requirements:
1. Add Task – System should allow adding new tasks with ID, name, and priority.
2. Add Dependencies – Each task can depend on one or more other tasks.
3. Check Dependencies – Scheduler verifies all dependent tasks are completed before running.
4. Execute Tasks – Tasks execute only when eligible (all dependencies done).
5. Cancel Task – A pending task can be removed before execution.
6. Track Status – Each task must show status: Pending, Running, or Completed.
7. Sequential Execution – Tasks execute in correct dependency order.
8. Completion Guarantee – Scheduler runs until all tasks are completed or cancelled.

Non-Functional Requirements:
1. Reliability – Scheduler should correctly handle dependencies and avoid errors.
2. Maintainability – Code must be modular and easy to modify or extend.
3. Scalability – Should handle large numbers of tasks efficiently.
4. Readability – Code should remain simple, structured, and beginner-friendly.
5. Error Handling – Should handle missing or invalid dependencies gracefully.
6. Deterministic Behavior – Execution order should always remain consistent.
7. Resource Efficiency – Use minimal memory and CPU while running.
8. Extensibility – Should allow future features like timed or parallel scheduling.

------------------------------------------------------------------------------------------------------------------------------------
Approach:
1. Make a TaskItem class to store task details like id, name, and dependencies.
2. Make a TaskScheduler class to manage all tasks and run them one by one.
3. Before running a task, check if all tasks it depends on are completed.
4. If dependencies are done, run the task and mark it as completed.
5. Keep looping until every task is finished or cancelled.
6. Show task status as Pending, Running, or Completed while running.
7. Code is kept simple so it can be easily understood or improved later.



USING TOPOLOGICAL SORT TO FIND CYCLE


#include <iostream>    // for input-output
#include <vector>      // for vector container
#include <queue>       // for queue used in topological sort
using namespace std;   // to avoid writing std:: everywhere

// Class to represent a single task
class Task {
public:
    int id;                   // unique task ID
    vector<Task*> deps;       // list of dependent task pointers

    Task(int i) { id = i; }   // constructor to set task ID
};

// Class to manage all tasks and run them in dependency order
class TaskScheduler {
    vector<Task*> tasks;             // list of all tasks
    vector<vector<int>> adj;         // adjacency list for dependencies
    vector<int> indegree;            // count of dependencies for each task

public:
    void addTask(Task* t) {          // add a task to scheduler
        tasks.push_back(t);          // store pointer to the new task
    }

    int findIndex(Task* t) {         // find index of a given task pointer
        for (int i = 0; i < tasks.size(); i++)  // loop through all tasks
            if (tasks[i] == t)                  // if pointer matches
                return i;                       // return its index
        return -1;                              // return -1 if not found
    }

    void buildGraph() {               // build adjacency list from task dependencies
        int n = tasks.size();         // total number of tasks
        adj = vector<vector<int>>(n); // create n empty lists
        indegree = vector<int>(n, 0); // initialize indegree count as 0 for all tasks

        for (int i = 0; i < n; i++) {               // loop through all tasks
            for (Task* dep : tasks[i]->deps) {      // for each dependency
                int from = findIndex(dep);          // find index of dependency task
                if (from == -1) continue;           // skip if dependency not found
                adj[from].push_back(i);             // add edge: dep → current task
                indegree[i]++;                      // increase indegree of current task
            }
        }
    }

    void run() {                         // run tasks in topological order
        buildGraph();                    // first, build dependency graph
        queue<int> q;                    // queue for Kahn’s algorithm

        for (int i = 0; i < indegree.size(); i++)   // push all tasks with 0 indegree
            if (indegree[i] == 0) q.push(i);

        int done = 0;                    // counter for executed tasks
        while (!q.empty()) {             // while there are tasks with no dependencies
            int curr = q.front();        // get the front task
            q.pop();                     // remove it from queue
            cout << "Executing Task " << tasks[curr]->id << endl;  // run task
            done++;                      // mark one task done

            for (int next : adj[curr]) { // for all dependent tasks
                indegree[next]--;        // reduce their dependency count
                if (indegree[next] == 0) // if no more dependencies left
                    q.push(next);        // add to queue
            }
        }

        if (done != tasks.size())        // if some tasks not done → cycle exists
            cout << "Error: Cycle detected!" << endl;
        else
            cout << "✅ All tasks executed successfully!" << endl;
    }
};

int main() {
    TaskScheduler scheduler;          // create the scheduler

    Task* A = new Task(1);            // create task A with ID 1
    Task* B = new Task(2);            // create task B with ID 2
    Task* C = new Task(3);            // create task C with ID 3

    B->deps.push_back(A);             // B depends on A
    C->deps.push_back(B);             // C depends on B

    scheduler.addTask(A);             // add A to scheduler
    scheduler.addTask(B);             // add B to scheduler
    scheduler.addTask(C);             // add C to scheduler

    scheduler.run();                  // execute tasks in correct order

    delete A; delete B; delete C;     // free memory

    return 0;                         // end program
}


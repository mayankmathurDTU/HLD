# üöó Smart Parking System (Priority Queue Based Nearest Spot Finder)

## üí° Overview
A parking system that finds the **nearest available parking spot** using a **priority queue (min-heap)**.
Each gate maintains its own heap for quick and efficient nearest spot lookup.

---

## ‚öôÔ∏è Flow
1. Admin defines parking spots, gates, and their distances.
2. Each gate builds a **min-heap** with pairs {distance, spotId} for all available spots.
3. When a vehicle enters, system picks the **nearest spot** from the heap top.
4. When a spot is booked ‚Üí it‚Äôs **popped** from the heap.
5. When a spot is freed ‚Üí it‚Äôs **pushed back** into the heap.
6. System continuously keeps heaps updated to always reflect the nearest free spots.

---

## üß© Core Entities
- **Gate** ‚Üí Entry/exit point; maintains a priority queue for nearby spots.
- **ParkingSpot** ‚Üí Each parking space; has type, ID, and availability.
- **Vehicle** ‚Üí User‚Äôs vehicle requesting a spot.
- **ParkingLot** ‚Üí Central controller managing all gates and spots.
- **Ticket** ‚Üí Issued when a spot is allocated; released on exit.

---

## üß† Nearest Spot Finding Strategy
- Each **Gate** stores a **priority queue** (min-heap) ‚Üí `{distance, spotId}`.
- Only **available spots** are kept in the heap.
- **Top element** always gives the **nearest available spot**.
- When a spot is booked ‚Üí remove from heap.
- When it becomes free ‚Üí push it back.
- Lookup = **O(1)**, Update (add/remove) = **O(log n)**.

---

## ‚úÖ Functional Requirements (FR)
- System should allocate nearest available spot to a vehicle.
- Should support multiple gates and parking types.
- Should update spot availability in real time.
- Should generate and close tickets properly.

---

## üöÄ Non-Functional Requirements (NFR)
- Fast lookup for spot allocation (low latency).
- Scalable for large parking lots.
- Consistent and thread-safe data updates.
- High availability and fault tolerance.


# üöß Problem:
# Each gate maintains its own priority queue (PQ) of nearest parking spots.
# When a vehicle parks through Gate 1, the allocated spot is removed from Gate 1‚Äôs PQ,
# but that same spot still exists in other gates‚Äô PQs (e.g., Gate 2).
# So Gate 2 may try to allocate an already occupied spot ‚Äî this is called stale data.

# ‚úÖ Solution:
# Use a "lazy cleanup" approach.
# When picking a spot from a PQ, keep popping until we find one that is actually free.
# If a spot is already occupied (spot->free == false), we skip it and pop the next.
# This way, old/stale entries are automatically ignored at runtime,
# avoiding costly PQ updates across all gates.



#include <bits/stdc++.h>                     // Include all standard C++ libraries
using namespace std;
using Clock = chrono::system_clock;          // Alias for tracking entry/exit time

//==========================================================
// ENUM: VehicleType
// Defines vehicle categories (2-wheeler or 4-wheeler)
//==========================================================
enum class VehicleType { TWO, FOUR };        // Enum for vehicle types

//==========================================================
// CLASS: Vehicle
// Represents a vehicle entering the parking lot
//==========================================================
class Vehicle {
public:
    string plate;                            // Variable: vehicle number plate
    VehicleType type;                        // Variable: vehicle type
    Vehicle(string p, VehicleType t) : plate(p), type(t) {}  // Constructor
};

//==========================================================
// CLASS: ParkingSpot
// Represents a single parking spot in the parking lot
//==========================================================
class ParkingSpot {
public:
    string id;                               // Variable: unique spot ID
    int floor, num;                          // Variable: floor and spot number
    VehicleType type;                        // Variable: spot supports TWO/FOUR wheeler
    bool free;                               // Variable: true if spot is available
    map<string, int> dist;                   // Variable: distance of this spot from each gate

    ParkingSpot(string i, int f, int n, VehicleType t)        // Constructor
        : id(i), floor(f), num(n), type(t), free(true) {}     // Initialize spot as free
};

//==========================================================
// CLASS: Gate
// Represents entry/exit gate and maintains nearest free spots
//==========================================================
class Gate {
public:
    string id;                               // Variable: gate ID
    bool entry, exit;                        // Variable: gate role flags (entry/exit)
    unordered_map<VehicleType,               // Variable: map by vehicle type
        priority_queue<pair<int, string>,    // PQ stores {distance, spotId}
        vector<pair<int, string>>, greater<>>> pq; // Min-heap (nearest first)
    
    Gate(string i, bool e, bool x) : id(i), entry(e), exit(x) {}  // Constructor
};

//==========================================================
// CLASS: Ticket
// Represents a parking ticket issued on entry
//==========================================================
class Ticket {
public:
    string id;                               // Variable: ticket ID
    Vehicle v;                               // Variable: vehicle associated
    ParkingSpot* s;                          // Variable: spot assigned to vehicle
    Clock::time_point in;                    // Variable: time of entry

    Ticket(string tid, Vehicle v_, ParkingSpot* s_)           // Constructor
        : id(tid), v(v_), s(s_), in(Clock::now()) {}          // Record entry time
};

//==========================================================
// INTERFACE CLASS: SpotSelectionStrategy
// Defines API for selecting nearest available spot (Strategy pattern)
//==========================================================
class SpotSelectionStrategy {
public:
    virtual ParkingSpot* selectSpot(         // API: choose best parking spot
        Gate* gate, unordered_map<string, ParkingSpot*>& spots, VehicleType type) = 0;
    virtual ~SpotSelectionStrategy() = default; // Virtual destructor
};

//==========================================================
// CLASS: NearestFirstStrategy (Strategy Implementation)
// Selects the closest available spot using gate PQ
//==========================================================
class NearestFirstStrategy : public SpotSelectionStrategy {
public:
    ParkingSpot* selectSpot(                 // API: override selection strategy
        Gate* gate, unordered_map<string, ParkingSpot*>& spots, VehicleType type) override {
        
        auto& pq = gate->pq[type];           // Variable: access gate‚Äôs priority queue
        while (!pq.empty()) {                // Loop: until queue becomes empty
            auto [d, sid] = pq.top(); pq.pop();  // Pop nearest spot info
            auto it = spots.find(sid);           // Lookup spot pointer by ID
            if (it != spots.end() && it->second->free) // If spot exists and is free
                return it->second;           // Return the free nearest spot
        }
        return nullptr;                      // No available spot found
    }
};

//==========================================================
// CLASS: ParkingLot (Main Context Class)
// Manages gates, spots, tickets, and applies strategy
//==========================================================
class ParkingLot {
    map<string, Gate*> gates;                // Variable: all gates by ID
    unordered_map<string, ParkingSpot*> spots;  // Variable: all parking spots by ID
    map<string, Ticket*> active;             // Variable: active tickets (ongoing parking)
    int ticketCounter = 0;                   // Variable: ticket number generator
    SpotSelectionStrategy* strategy;         // Variable: strategy pointer (composition)

public:
    ParkingLot(SpotSelectionStrategy* s) : strategy(s) {}  // Constructor injects strategy

    void addSpot(ParkingSpot* s) { spots[s->id] = s; }     // API: add new parking spot
    void addGate(Gate* g) { gates[g->id] = g; }            // API: add new gate

    int dist(ParkingSpot* s, Gate* g) {                    // API: compute distance (dummy logic)
        return abs(s->floor - 0) * 100 + s->num;           // Example distance formula
    }

    void precompute() {                                    // API: fill gate PQs initially
        for (auto& [gid, g] : gates)                       // For each gate
            for (auto& [sid, s] : spots) {                 // For each spot
                int d = dist(s, g);                        // Compute distance
                s->dist[gid] = d;                          // Store per-gate distance
                if (s->free)                               // If free, add to PQ
                    g->pq[s->type].push({d, s->id});
            }
    }

    string park(string gid, Vehicle v) {                   // API: park a vehicle at given gate
        if (!gates.count(gid)) { cout << "Invalid gate\n"; return ""; } // Validate gate
        Gate* g = gates[gid];                              // Get gate pointer
        ParkingSpot* spot = strategy->selectSpot(g, spots, v.type); // Use strategy to find spot
        if (!spot) { cout << "No spot available\n"; return ""; }    // Handle no availability

        spot->free = false;                                // Mark spot as occupied
        string tid = "T" + to_string(++ticketCounter);      // Generate ticket ID
        active[tid] = new Ticket(tid, v, spot);             // Create and store ticket
        cout << v.plate << " parked at " << spot->id << " (Ticket " << tid << ")\n"; // Log info
        return tid;                                         // Return ticket ID
    }

    void unpark(string tid, string gid) {                   // API: unpark vehicle using ticket
        if (!active.count(tid)) { cout << "Invalid ticket\n"; return; } // Validate ticket
        Ticket* t = active[tid];                            // Get ticket info
        ParkingSpot* s = t->s;                              // Get associated spot
        s->free = true;                                     // Mark spot as free again

        for (auto& [gid2, g] : gates)                       // For each gate
            g->pq[s->type].push({s->dist[gid2], s->id});    // Add spot back to PQs

        double hrs = chrono::duration_cast<chrono::hours>(Clock::now() - t->in).count() + 1; // Compute duration
        double rate = (s->type == VehicleType::TWO ? 10 : 20); // Set rate by vehicle type
        cout << tid << " exited, Fee: " << hrs * rate << "\n"; // Print parking fee

        delete t; active.erase(tid);                        // Delete ticket from active map
    }
};

//==========================================================
// MAIN FUNCTION (Driver code)
// Demonstrates NearestFirstStrategy in action
//==========================================================
int main() {
    SpotSelectionStrategy* strat = new NearestFirstStrategy(); // Variable: chosen strategy
    ParkingLot lot(strat);                      // Variable: parking lot with strategy

    // Create spots for 2 floors, 4 spots each
    for (int f = 0; f < 2; f++)
        for (int i = 1; i <= 4; i++)
            lot.addSpot(new ParkingSpot(         // API: add parking spot
                "F" + to_string(f) + "_S" + to_string(i),
                f, i,
                (i % 2) ? VehicleType::FOUR : VehicleType::TWO)); // Alternate types

    lot.addGate(new Gate("G1", true, true));     // API: add gate 1
    lot.addGate(new Gate("G2", true, true));     // API: add gate 2
    lot.precompute();                            // API: precompute distances & PQs

    Vehicle car("CAR123", VehicleType::FOUR);    // Variable: car object
    Vehicle bike("BIKE456", VehicleType::TWO);   // Variable: bike object

    string t1 = lot.park("G1", car);             // API: park car at gate G1
    string t2 = lot.park("G1", bike);            // API: park bike at gate G1
    this_thread::sleep_for(chrono::seconds(1));  // Simulate time delay
    lot.unpark(t1, "G2");                        // API: unpark car at gate G2
    lot.unpark(t2, "G1");                        // API: unpark bike at gate G1
}

-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Functional Requirements
1. allow creation parking lot with multiple floors and parking spots.  
2. Support multiple entry and exit gates.  
3. Park vehicles (2-wheeler / 4-wheeler) and assign the nearest available spot from the chosen entry gate.  
4. On entry, issue a ticket with timestamp and assigned spot.  
5. On exit, accept the ticket, calculate hourly charges (round up partial hours), and free the spot.  
6. Rates should be configurable per vehicle type.  
7. If no spot is available, show a clear message: **"No Spot Available."**  

# Non-Functional Requirements (NFR)
1. Fast nearest-spot lookup for a gate (low latency on entry).  
2. Reasonable memory usage for storing spot metadata.  
3. Concurrency support ‚Äì system should handle many requests at the same time  
   (locking and thread-safety noted, but not implemented in simple demo).  
4. Extensible design so that new vehicle types or billing strategies can be added easily.  
5. Maintainability and testability ‚Äì code should be easy to understand, modify, and test.  


# Design Patterns
## Strategy Pattern
- Where: Spot selection logic (SpotSelectionStrategy, NearestSpotStrategy, FarthestSpotStrategy).  
- Why: Allows changing parking spot selection policy (nearest, farthest, random, VIP) without modifying ParkingLot. Follows Open/Closed Principle.  
- How: Inject strategy into ParkingLot:  
  `SpotSelectionStrategy* strategy;`  
  `strategy->selectSpot(candidates, gateId);`
  We precompute the distance of every parking spot from each entry gate using a simple 
  formula: vertical distance (difference in floors √ó 100) plus horizontal distance (spot index). 
  When a vehicle arrives, the NearestSpotStrategy loops over available spots of the correct type, 
  compares their precomputed distances from that entry gate, and selects the spot with the minimum 
  distance as the ‚Äúnearest first.‚Äù
  
## Factory Pattern (conceptual)
- Where: Creation of ParkingSpot, Floor, Vehicle (in main or setup).  
- Why: Centralizes object creation, makes it easy to add new spot/vehicle types later (compact, large, EV).  
- Note: Not a separate factory class in current code, but object creation is centralized.


# Core Entities

- ParkingLot: Top-level coordinator / manager of the parking system.  
- Floor: Contains parking spots.  
- ParkingSpot: A physical slot with type, availability, and distances to gates.  
- Gate: Entry/exit point; maintains pre-sorted spot lists by distance for each vehicle type.  
- Vehicle: Represents a vehicle and its type (2-wheeler / 4-wheeler).  
- Ticket: Issued at entry; includes vehicle, assigned spot, entry time, and ticket ID.  
- PaymentService: Computes charges based on hourly rates.  
- NearestSpotStrategy: Conceptual strategy to pick nearest spot; implemented by scanning pre-sorted lists.  


-----------------------------------------------------------------------------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Represents type of vehicle
enum class VehicleType { TWO_WHEELER, FOUR_WHEELER };

class Vehicle {
    string plate;                 // Vehicle registration number
    VehicleType type;             // Vehicle type (2W/4W)
public:
    Vehicle(const string& p, VehicleType t) : plate(p), type(t) {}
    VehicleType getType() const { return type; }   // returns vehicle type
    string getPlate() const { return plate; }      // returns vehicle number
};

class ParkingSpot {
    string id;                               // unique id of spot
    int floorNumber;                         // floor number of this spot
    int spotNumber;                          // index/serial number of spot
    VehicleType spotType;                    // which type of vehicle this spot supports
    bool occupied;                           // true if vehicle parked
    string occupyingTicketId;                // ticket id of occupying vehicle
    map<string, int> distancesFromGate;      // precomputed distance from each gate
        //when finding neareast gate, we get a stirng gateId
        // every spot knows its distance from that gate.
public:
    ParkingSpot(const string& i, int f, int sn, VehicleType st)
        : id(i), floorNumber(f), spotNumber(sn), spotType(st), occupied(false) {}

    bool isAvailable() const { return !occupied; }        // check availability
    void occupy(const string& ticketId) {                 // mark spot as occupied
        occupied = true; occupyingTicketId = ticketId;
    }
    void freeSpot() { occupied = false; occupyingTicketId = ""; } // free spot

    string getId() const { return id; }                   // get spot id
    int getFloorNumber() const { return floorNumber; }    // get floor number
    int getSpotNumber() const { return spotNumber; }      // get spot number
    VehicleType getSpotType() const { return spotType; }  // get spot type

    void setDistance(const string& gateId, int d) { distancesFromGate[gateId] = d; } // set distance
    int getDistance(const string& gateId) const { return distancesFromGate.at(gateId); } // get distance
};

class Floor {
    int floorNumber;                  // floor number
    vector<ParkingSpot*> spots;       // collection of spots on this floor
public:
    Floor(int n) : floorNumber(n) {}
    void addSpot(ParkingSpot* s) { spots.push_back(s); }         // add a spot
    const vector<ParkingSpot*>& getSpots() const { return spots; } // get all spots
    int getFloorNumber() const { return floorNumber; }           // get floor number
};

class Gate {
    string id;                                        // unique gate id
    string name;                                      // gate name
    int floorNumber;                                  // floor where gate is located
    bool entry;                                       // true if entry gate
    bool exit;                                        // true if exit gate
public:
    Gate(const string& gid, const string& gname, int fnum, bool entryGate, bool exitGate)
        : id(gid), name(gname), floorNumber(fnum), entry(entryGate), exit(exitGate) {}

    string getId() const { return id; }               // get gate id
    string getName() const { return name; }           // get gate name
    bool isEntryGate() const { return entry; }        // check if entry
    bool isExitGate() const { return exit; }          // check if exit
    int getFloorNumber() const { return floorNumber; }// get floor number
};

class Ticket {
    string id;                          // ticket id
    Vehicle vehicle;                     // vehicle assigned
    ParkingSpot* spot;                   // spot assigned
    Clock::time_point entryTime;         // entry timestamp
    bool active;                         // true if active
public:
    Ticket(const string& tid, const Vehicle& v, ParkingSpot* s)
        : id(tid), vehicle(v), spot(s), entryTime(Clock::now()), active(true) {}

    string getId() const { return id; }               // get ticket id
    Vehicle getVehicle() const { return vehicle; }    // get vehicle info
    ParkingSpot* getSpot() const { return spot; }     // get spot pointer
    Clock::time_point getEntryTime() const { return entryTime; } // get entry time
    bool isActive() const { return active; }          // check if active
    void deactivate() { active = false; }             // deactivate ticket
};

class PaymentService {
    map<VehicleType, double> hourlyRate; // rate per hour per vehicle type
public:
    PaymentService() {
        hourlyRate[VehicleType::TWO_WHEELER] = 10.0;   // 10 per hr for 2W
        hourlyRate[VehicleType::FOUR_WHEELER] = 20.0;  // 20 per hr for 4W
    }
    double computeFee(const Ticket* t, const Clock::time_point& exitTime) {
        long long minutes = chrono::duration_cast<chrono::minutes>(exitTime - t->getEntryTime()).count();
        if (minutes <= 0) minutes = 0;
        long long hours = (minutes + 59) / 60;  // round up
        double rate = hourlyRate.at(t->getVehicle().getType());
        return rate * hours;
    }
};

class SpotSelectionStrategy {
public:
    virtual ParkingSpot* selectSpot(const vector<ParkingSpot*>& spots, const string& gateId) = 0; // abstract
    virtual ~SpotSelectionStrategy() {}
};

// Select nearest available spot
// to calculate this distance between spot and gate we can use 
// abs(spot->floor()-gate->floot())*100 (100 is penalty) + spot->id() (id is like index) horizontal distance from gate
class NearestSpotStrategy : public SpotSelectionStrategy {
public:
    ParkingSpot* selectSpot(const vector<ParkingSpot*>& spots, const string& gateId) override {
        ParkingSpot* chosen = nullptr;
        int bestDist = INT_MAX;
        for (ParkingSpot* sp : spots) {
            if (sp->isAvailable()) {
                int d = sp->getDistance(gateId);
                if (d < bestDist) {
                    bestDist = d; chosen = sp;
                }
            }
        }
        return chosen;
    }
};

// Select farthest available spot
class FarthestSpotStrategy : public SpotSelectionStrategy {
public:
    ParkingSpot* selectSpot(const vector<ParkingSpot*>& spots, const string& gateId) override {
        ParkingSpot* chosen = nullptr;
        int bestDist = -1;
        for (ParkingSpot* sp : spots) {
            if (sp->isAvailable()) {
                int d = sp->getDistance(gateId);
                if (d > bestDist) {
                    bestDist = d; chosen = sp;
                }
            }
        }
        return chosen;
    }
};

/////////////////////////////////////////////////////////////
// PARKING LOT CLASS
/////////////////////////////////////////////////////////////

class ParkingLot {
    string id;                                        // parking lot id
    vector<Floor*> floors;                            // list of floors
    map<string, Gate*> gates;                         // all gates
    map<string, ParkingSpot*> allSpots;               // spotId -> spot*// all spots of all floors 
    map<string, Ticket*> activeTickets;               // active tickets
    PaymentService paymentService;                    // payment service
    int ticketCounter;                                // counter for ticket ids
    SpotSelectionStrategy* strategy;                  // strategy for selecting spot
public:
    ParkingLot(const string& pid, SpotSelectionStrategy* s)
        : id(pid), ticketCounter(0), strategy(s) {}
    ~ParkingLot() {
        for (auto& p : allSpots) delete p.second;
        for (auto f : floors) delete f;
        for (auto& g : gates) delete g.second;
        for (auto& t : activeTickets) delete t.second;
    }

    void addFloor(Floor* f) {
        floors.push_back(f);
        for (auto s : f->getSpots()) {
            allSpots[s->getId()] = s;
        }
    }

    void addGate(Gate* g) { gates[g->getId()] = g; }

    // compute distance between spot and gate
    int computeDistance(ParkingSpot* s, Gate* g) {
        int vertical = abs(s->getFloorNumber() - g->getFloorNumber()) * 100; // penalty per floor
        int horizontal = s->getSpotNumber(); // simple index as distance
        return vertical + horizontal;
    }

   void precompute() {
    // For every gate
    for (auto& gateEntry : gates) {
        Gate* gate = gateEntry.second;

        // For every parking spot
        for (auto& spotEntry : allSpots) {
            ParkingSpot* spot = spotEntry.second;

            // Calculate distance from this gate to this spot
            int dist = computeDistance(spot, gate);

            // Store this distance in the spot‚Äôs distance map
            spot->setDistance(gateEntry.first, dist);
           }
       }
   }

    // Park a vehicle using selected strategy
    string parkVehicle(const string& gateId, const Vehicle& vehicle) {
        if (gates.count(gateId) == 0) {
            cout << "Gate not found\n"; return "";
        }
        Gate* gate = gates[gateId];
        if (!gate->isEntryGate()) {
            cout << "Not an entry gate\n"; return "";
        }

        // collect candidate spots of required type
        vector<ParkingSpot*> candidates;
        for (auto& kv : allSpots) {
            ParkingSpot* sp = kv.second;
            if (sp->getSpotType() == vehicle.getType()) candidates.push_back(sp);
        }

        // strategy chooses spot
        ParkingSpot* chosen = strategy->selectSpot(candidates, gateId);
        if (!chosen) {
            cout << "No spot available\n"; return "";
        }

        ticketCounter++;
        string ticketId = "T" + to_string(ticketCounter);
        chosen->occupy(ticketId);
        Ticket* t = new Ticket(ticketId, vehicle, chosen);
        activeTickets[ticketId] = t;
        cout << "Vehicle " << vehicle.getPlate() << " parked at " << chosen->getId()
             << " (Ticket " << ticketId << ")\n";
        return ticketId;
    }

    // Exit and calculate fee
    double exitVehicle(const string& ticketId, const string& exitGateId) {
        if (activeTickets.count(ticketId) == 0) {
            cout << "Invalid ticket\n"; return -1.0;
        }
        if (gates.count(exitGateId) == 0) {
            cout << "Exit gate not found\n"; return -1.0;
        }
        Ticket* t = activeTickets[ticketId];
        double fee = paymentService.computeFee(t, Clock::now());
        ParkingSpot* sp = t->getSpot();
        sp->freeSpot();
        t->deactivate();
        activeTickets.erase(ticketId);
        cout << "Ticket " << ticketId << " exited, Fee: " << fee << "\n";
        delete t;
        return fee;
    }
};

/////////////////////////////////////////////////////////////
// DEMO MAIN
/////////////////////////////////////////////////////////////

int main() {
    // Use nearest strategy
    SpotSelectionStrategy* nearest = new NearestSpotStrategy();
    ParkingLot lot("P1", nearest);

    // Create 2 floors with some spots
    for (int fl = 0; fl < 2; ++fl) {
        Floor* f = new Floor(fl);
        int spotIndex = 1;
        for (int i = 0; i < 4; ++i) {
            VehicleType st = (i % 2 == 0) ? VehicleType::FOUR_WHEELER : VehicleType::TWO_WHEELER;
            string sid = "F" + to_string(fl) + "_S" + to_string(spotIndex);
            ParkingSpot* sp = new ParkingSpot(sid, fl, spotIndex, st);
            f->addSpot(sp);
            spotIndex++;
        }
        lot.addFloor(f);
    }

    // Add gates
    Gate* g1 = new Gate("G1", "Main Gate Ground", 0, true, true);
    Gate* g2 = new Gate("G2", "Side Gate First", 1, true, true);
    lot.addGate(g1);
    lot.addGate(g2);

    // Precompute distances
    lot.precompute();

    // Park vehicles
    Vehicle car("CAR123", VehicleType::FOUR_WHEELER);
    string tk1 = lot.parkVehicle("G1", car);

    Vehicle bike("BIKE456", VehicleType::TWO_WHEELER);
    string tk2 = lot.parkVehicle("G1", bike);

    // Exit vehicles
    lot.exitVehicle(tk1, "G2");
    lot.exitVehicle(tk2, "G1");

    delete nearest; // cleanup
    return 0;
}


===========================  
üéØ APPROACH  
===========================
1Ô∏è‚É£ User sends a chat message request (with model name and messages).  
2Ô∏è‚É£ ChatService checks if request is valid (model + message present).  
3Ô∏è‚É£ ChatService asks Responder (like MockResponder) to create a reply.  
4Ô∏è‚É£ Responder generates and returns the reply.  
5Ô∏è‚É£ ChatResponse is sent back with either reply or error message.  


===========================  
‚öôÔ∏è FUNCTIONAL REQUIREMENTS (FR)  
===========================
| FR ID | Description |
|--------|-------------|
| FR1 | System should accept a chat request with model and messages |
| FR2 | It should validate the request (model name, messages) |
| FR3 | It should generate a reply using the selected responder |
| FR4 | It should return a proper ChatResponse with message or error |


===========================  
üöÄ NON-FUNCTIONAL REQUIREMENTS (NFR)  
===========================
| NFR ID | Description |
|---------|-------------|
| NFR1 | Code should be modular (easy to add new responder types) |
| NFR2 | System should be fast for single message processing |
| NFR3 | Should handle invalid or empty requests safely |
| NFR4 | Should be easy to test and maintain |


===========================  
üèóÔ∏è CORE ENTITIES  
===========================
| Entity | Description |
|---------|-------------|
| Message | Represents one message from user or assistant |
| ChatRequest | Holds model name and list of messages |
| ChatResponse | Holds reply or error details |
| IResponder | Interface for all responder implementations |
| MockResponder | Simple responder that echoes back the input |
| ChatService | Main service that validates and calls responder |


===========================  
üåê API DESIGN  
===========================
| API Name | getChatResponse() |
|-----------|------------------|
| Input | ChatRequest (model, messages) |
| Output | ChatResponse (reply or error) |
| Errors | Missing model name, empty message list |
| Example | Input: "Hello there!" ‚Üí Output: "Echo: Hello there!" |

-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------


#include <iostream>    // for input-output
#include <string>      // for string class
#include <vector>      // for vector
using namespace std;

// Class to represent one chat message
class Message {
public:
    string role;      // who sent it: "user" or "assistant"
    string content;   // message text

    // constructor to quickly create a message
    Message(string r, string c) : role(r), content(c) {}
};

// Class for request sent to chat system
class ChatRequest {
public:
    string model;              // name of model, e.g. "mock-v1"
    vector<Message> messages;  // all chat messages (user + bot)
};

// Class for response from chat system
class ChatResponse {
public:
    string reply;      // reply generated by system
    bool error = false; // true if something went wrong
    string errorMsg;    // text for error message
};

// Interface (base class) for responder logic
class IResponder {
public:
    // pure virtual function ‚Äî must be defined in child class
    virtual string generate(const ChatRequest& req) = 0;

    // virtual destructor for safety
    virtual ~IResponder() = default;
};

// Simple implementation: just repeats user message
class MockResponder : public IResponder {
public:
    // generate response based on last user message
    string generate(const ChatRequest& req) override {
        if (req.messages.empty()) return "No input message!";  // if no message found
        return "Echo: " + req.messages.back().content;         // reply with last message
    }
};

// ChatService = main logic that connects everything
class ChatService {
    IResponder* responder; // pointer to responder (strategy)
public:
    // constructor to inject responder
    ChatService(IResponder* r) : responder(r) {}

    // main function to process chat request and return reply
    ChatResponse getChatResponse(const ChatRequest& req) {
        ChatResponse resp;   // create response object

        // check if model name is missing
        if (req.model.empty()) {
            resp.error = true;
            resp.errorMsg = "Model name missing!";
            return resp;
        }

        // check if any messages were sent
        if (req.messages.empty()) {
            resp.error = true;
            resp.errorMsg = "No messages found!";
            return resp;
        }

        // call responder to generate reply
        resp.reply = responder->generate(req);
        return resp;
    }
};

// Main function for testing
int main() {
    MockResponder mock;                    // create mock responder
    ChatService service(&mock);            // pass it to service

    ChatRequest req;                       // create a request
    req.model = "mock-v1";                 // set model name
    req.messages.push_back({"user", "Hello there!"});  // add user message

    ChatResponse res = service.getChatResponse(req);   // get reply

    // print result based on success or error
    if (res.error)
        cout << "Error: " << res.errorMsg << endl;     // show error
    else
        cout << "Chatbot Reply: " << res.reply << endl; // show reply

    return 0;  // end program
}
